# app.py
import os
import time
import json
import logging
from typing import Optional, List

import requests
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware

# ---------------- CONFIG ----------------
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")

HF_API_TOKEN = os.getenv("HF_API_TOKEN")              # unused now
HF_MODEL = "google/flan-t5-base"
HF_URL = f"https://api-inference.huggingface.co/models/{HF_MODEL}"

# OPENROUTER (LLM AD GENERATION)
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions"
OPENROUTER_MODEL = "openai/gpt-4o"

# GEOAPIFY KEY
GEOAPIFY_KEY = os.getenv("GEOAPIFY_API_KEY")

CACHE_TTL = 300
PORT = 8000
MAX_HF_RETRIES = 3
HF_TIMEOUT = 20

DEFAULT_RADIUS_METERS = 2000
DEFAULT_LIMIT = 20

logging.basicConfig(level=LOG_LEVEL)
logger = logging.getLogger("ad-backend")

app = FastAPI(title="AI Ad Aware Backend")

# ---------------- CORS ----------------
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --------------- MODELS --------------
class POI(BaseModel):
    name: str
    address: Optional[str]
    lat: float
    lon: float
    category: Optional[str]

class OfferItem(BaseModel):
    poi_name: Optional[str]
    category: Optional[str]
    offer_title: str
    offer_body: str
    discount_percent: Optional[float]
    valid_till: Optional[str]

class OfferWithPOI(BaseModel):
    poi: POI
    offer: OfferItem

class GeneratedAd(BaseModel):
    poi_name: str
    address: Optional[str]
    category: Optional[str]
    offer_title: str
    offer_body: str
    discount_percent: Optional[float]
    ad_title: str
    ad_text: str
    cta_text: str

# --------------- CACHE ---------------
class TTLCache:
    def __init__(self, ttl):
        self.ttl = ttl
        self.store = {}

    def get(self, k):
        v = self.store.get(k)
        if not v:
            return None
        if time.time() - v["ts"] > self.ttl:
            del self.store[k]
            return None
        return v["val"]

    def set(self, k, v):
        self.store[k] = {"val": v, "ts": time.time()}

poi_cache = TTLCache(CACHE_TTL)

# ---------------- LOAD OFFERS JSON ----------------
OFFERS_FILE = "offers.json"

def load_offers():
    try:
        with open(OFFERS_FILE, "r", encoding="utf-8") as f:
            offers_raw = json.load(f)
            offers = [OfferItem(**o) for o in offers_raw]
            print(f"[INFO] Loaded {len(offers)} offers.")
            return offers
    except Exception as e:
        print(f"[ERROR] Failed to load offers: {e}")
        return []

OFFERS_DB = load_offers()

# Build indexes
OFFERS_BY_NAME = {}
OFFERS_BY_CATEGORY = {}

for offer in OFFERS_DB:
    if offer.poi_name:
        key = offer.poi_name.strip().lower()
        OFFERS_BY_NAME.setdefault(key, []).append(offer)
    if offer.category:
        key = offer.category.strip().lower()
        OFFERS_BY_CATEGORY.setdefault(key, []).append(offer)

# ---------------- OSM FALLBACK ----------------
def build_osm_address(tags):
    if not tags:
        return None
    parts = []
    for key in ["addr:housenumber", "addr:street", "addr:suburb",
                "addr:city", "addr:state", "addr:postcode"]:
        v = tags.get(key)
        if v:
            parts.append(v)
    return ", ".join(parts) if parts else None

def fetch_pois_osm(lat, lon, radius=2000, limit=20):
    query = f"""
    [out:json][timeout:20];
    (
      node(around:{radius},{lat},{lon})["amenity"];
      node(around:{radius},{lat},{lon})["shop"];
      node(around:{radius},{lat},{lon})["tourism"];
      node(around:{radius},{lat},{lon})["leisure"];
    );
    out center;
    """
    r = requests.post("https://overpass-api.de/api/interpreter", data=query, timeout=25)
    r.raise_for_status()
    data = r.json()


    pois = []
    for el in data.get("elements", []):
        tags = el.get("tags", {})
        name = tags.get("name")
        if not name:
            continue

        la = el.get("lat") or el.get("center", {}).get("lat")
        lo = el.get("lon") or el.get("center", {}).get("lon")

        cat = tags.get("shop") or tags.get("amenity") or tags.get("tourism")
        addr = build_osm_address(tags)

        pois.append(POI(name=name, address=addr, lat=la, lon=lo, category=cat))
        if len(pois) >= limit:
            break
    return pois

# ---------------- GEOAPIFY PRIMARY ----------------
def fetch_pois_geoapify(lat, lon, radius=2000, limit=20):
    if not GEOAPIFY_KEY:
        raise Exception("GEOAPIFY_API_KEY missing")

    url = "https://api.geoapify.com/v2/places"
    params = {
        "apiKey": GEOAPIFY_KEY,
        "filter": f"circle:{lon},{lat},{radius}",
        "limit": limit,
        "categories": "commercial,service,entertainment,tourism,leisure,healthcare,education,food,shop"
    }

    r = requests.get(url, params=params, timeout=15)
    r.raise_for_status()
    data = r.json()

    pois = []
    for f in data.get("features", []):
        props = f.get("properties", {})
        coords = f.get("geometry", {}).get("coordinates", [None, None])
        lon2, lat2 = coords

        cat = (props.get("categories") or ["other"])[0]

        addr = (
            props.get("address_line2") or
            props.get("address_line1") or
            props.get("formatted")
        )

        pois.append(POI(
            name=props.get("name") or "Unknown place",
            address=addr,
            lat=lat2,
            lon=lon2,
            category=cat
        ))
        if len(pois) >= limit:
            break
    return pois

# ---------------- POI GETTER ----------------
def get_pois(lat, lon, radius=2000, limit=20):
    key = f"{lat}:{lon}:{radius}:{limit}"
    cached = poi_cache.get(key)
    if cached:
        return cached

    try:
        pois = fetch_pois_geoapify(lat, lon, radius, limit)
    except:
        pois = fetch_pois_osm(lat, lon, radius, limit)

    poi_cache.set(key, pois)
    return pois

# ---------------- OFFER MATCHING ----------------
def find_offer_for_poi(poi):
    # exact name match
    if poi.name:
        key = poi.name.lower()
        if key in OFFERS_BY_NAME:
            return OFFERS_BY_NAME[key][0]

    # category match
    if poi.category:
        cat = poi.category.lower().split(".")[0]
        if cat in OFFERS_BY_CATEGORY:
            return OFFERS_BY_CATEGORY[cat][0]

    return None

def attach_offers_to_pois(pois):
    result = []
    for poi in pois:
        offer = find_offer_for_poi(poi)
        if offer:
            result.append(OfferWithPOI(poi=poi, offer=offer))
    return result

# ---------------- OPENROUTER LLM ----------------
def call_openrouter(prompt: str) -> str:
    if not OPENROUTER_API_KEY:
        raise RuntimeError("OPENROUTER_API_KEY missing")

    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": OPENROUTER_MODEL,
        "messages": [{"role": "user", "content": prompt}]
    }

    resp = requests.post(
        OPENROUTER_URL,
        headers=headers,
        data=json.dumps(payload),
        timeout=40
    )
    resp.raise_for_status()
    data = resp.json()

    return data["choices"][0]["message"]["content"]

# ---------------- ROUTES ----------------
@app.get("/places/nearby")
def places(lat: float, lon: float):
    return get_pois(lat, lon)

@app.get("/offers/nearby", response_model=List[OfferWithPOI])
def offers(lat: float, lon: float):
    pois = get_pois(lat, lon)
    return attach_offers_to_pois(pois)

@app.get("/ads/nearby", response_model=List[GeneratedAd])
def template_ads(lat: float, lon: float):
    pois = get_pois(lat, lon)
    items = attach_offers_to_pois(pois)
    ads = []

    for item in items:
        poi, offer = item.poi, item.offer
        ads.append(GeneratedAd(
            poi_name=poi.name,
            address=poi.address,
            category=poi.category,
            offer_title=offer.offer_title,
            offer_body=offer.offer_body,
            discount_percent=offer.discount_percent,
            ad_title=f"{offer.offer_title} at {poi.name}",
            ad_text=f"{offer.offer_body} Visit {poi.name} ({poi.address or 'near you'}).",
            cta_text="View Offer"
        ))
    return ads

@app.get("/ads/llm-nearby", response_model=List[GeneratedAd])
def llm_ads(lat: float, lon: float):
    pois = get_pois(lat, lon)
    items = attach_offers_to_pois(pois)
    result = []

    for item in items:
        poi = item.poi
        offer = item.offer

        prompt = f"""
Write a catchy short ad for this:

Place: {poi.name}
Address: {poi.address}
Category: {poi.category}
Offer: {offer.offer_title}
Details: {offer.offer_body}
Discount: {offer.discount_percent}

Return format:
Title: 
Body:
CTA:
"""

        try:
            out = call_openrouter(prompt)
        except:
            # fallback
            out = f"Title: {offer.offer_title}\nBody: {offer.offer_body}\nCTA: View offer"

        title, body, cta = "","","View offer"
        for line in out.splitlines():
            if line.lower().startswith("title"):
                title = line.split(":",1)[1].strip()
            if line.lower().startswith("body"):
                body = line.split(":",1)[1].strip()
            if line.lower().startswith("cta"):
                cta = line.split(":",1)[1].strip()

        result.append(GeneratedAd(
            poi_name=poi.name,
            address=poi.address,
            category=poi.category,
            offer_title=offer.offer_title,
            offer_body=offer.offer_body,
            discount_percent=offer.discount_percent,
            ad_title=title or offer.offer_title,
            ad_text=body or offer.offer_body,
            cta_text=cta
        ))
    return result

@app.get("/health")
def health():
    return {
        "geoapify_key": bool(GEOAPIFY_KEY),
        "offers_loaded": len(OFFERS_DB),
        "llm_configured": bool(OPENROUTER_API_KEY)
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app:app", host="127.0.0.1", port=PORT, reload=True)
